{"ast":null,"code":"import { now } from '../../shared/utils.js';\nexport default function freeMode({\n  swiper,\n  extendParams,\n  emit,\n  once\n}) {\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n\n  function onTouchMove() {\n    const {\n      touchEventsData: data,\n      touches\n    } = swiper; // Velocity\n\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now()\n    });\n  }\n\n  function onTouchEnd({\n    currentPos\n  }) {\n    const {\n      params,\n      $wrapperEl,\n      rtlTranslate: rtl,\n      snapGrid,\n      touchEventsData: data\n    } = swiper; // Time diff\n\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(() => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(() => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchMove,\n      onTouchEnd\n    }\n  });\n}","map":{"version":3,"sources":["/Users/gianningamy/cryptobet/front-end/master/node_modules/swiper/modules/free-mode/free-mode.js"],"names":["now","freeMode","swiper","extendParams","emit","once","enabled","momentum","momentumRatio","momentumBounce","momentumBounceRatio","momentumVelocityRatio","sticky","minimumVelocity","onTouchMove","touchEventsData","data","touches","velocities","length","push","position","isHorizontal","time","touchStartTime","onTouchEnd","currentPos","params","$wrapperEl","rtlTranslate","rtl","snapGrid","touchEndTime","timeDiff","minTranslate","slideTo","activeIndex","maxTranslate","slides","lastMoveEvent","pop","velocityEvent","distance","velocity","Math","abs","momentumDuration","momentumDistance","newPosition","translate","doBounce","afterBouncePosition","bounceAmount","needsLoopFix","allowMomentumBounce","loop","centeredSlides","nextSlide","j","swipeDirection","loopFix","moveDistance","currentSlideSize","slidesSizesGrid","speed","slideToClosest","updateProgress","setTransition","setTranslate","transitionStart","animating","transitionEnd","destroyed","setTimeout","updateActiveIndex","updateSlidesClasses","longSwipesMs","Object","assign"],"mappings":"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","sourcesContent":["import { now } from '../../shared/utils.js';\nexport default function freeMode({\n  swiper,\n  extendParams,\n  emit,\n  once\n}) {\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n\n  function onTouchMove() {\n    const {\n      touchEventsData: data,\n      touches\n    } = swiper; // Velocity\n\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now()\n    });\n  }\n\n  function onTouchEnd({\n    currentPos\n  }) {\n    const {\n      params,\n      $wrapperEl,\n      rtlTranslate: rtl,\n      snapGrid,\n      touchEventsData: data\n    } = swiper; // Time diff\n\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(() => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(() => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchMove,\n      onTouchEnd\n    }\n  });\n}"]},"metadata":{},"sourceType":"module"}